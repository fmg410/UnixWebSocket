#include <iostream>
#include <SFML/Graphics.hpp>
#include <SFML/Network.hpp>
#include <vector>
#include <algorithm>
#include <type_traits>
#include <string>
#include <limits>

#ifdef _WIN32
#define clearConsole system("cls")
#elif __linux__
#define clearConsole system("clear")
#elif __APPLE__
#define clearConsole system("clear")
#else
#define clearConsole printf("\n\n\n")
#endif

static const int32_t appId_ = 518906510233;

/* const sf::Packet& operator>>(const sf::Packet& p, int32_t i)
{
    sf::Uint64 t;
    p >> t;
    t = static_cast<int32_t>(t);
    return p;
}

const sf::Packet& operator<<(const sf::Packet& p, int32_t i)
{
    p << static_cast<sf::Int64>(i);
    return p;
} */

struct Client
{
    std::string name;
    const sf::IpAddress adress;
    const unsigned short port;
    bool operator==(const Client &client)
    {
        return adress == client.adress && port == client.port;
    }
    bool operator!=(const Client &client)
    {
        return !(*this == client);
    }
};

enum class ClientMessageType
{
    HANDSHAKE = 1,
    CLIENTS_LIST_REQUEST = 2,
    MESSAGE_TO_CLIENT = 3
};

enum class ServerMessageType
{
    CLIENT_LIST = 1,
    MESSAGE_FROM_SOMEONE = 2
};

void runUdpServer(unsigned short serverPort)
{
    // std::cout << "Server run with local ip: " << sf::IpAddress::getLocalAddress() << "\nand public ip: " << sf::IpAddress::getPublicAddress() << std::endl;

    sf::UdpSocket socket;

    if (socket.bind(serverPort) != sf::Socket::Done)
        return;

    std::vector<Client> clients;

    sf::Packet receivedPacket;
    sf::IpAddress senderIp;
    unsigned short senderPort;
    std::size_t received;

    do
    {
        if (socket.receive(receivedPacket, senderIp, senderPort) != sf::Socket::Done)
            return;

        int32_t appId;

        if (!(receivedPacket >> appId && appId == appId_))
            continue;

        std::underlying_type_t<ClientMessageType> messageTypeTemp;
        if (!(receivedPacket >> messageTypeTemp))
            continue;

        ClientMessageType messageType = static_cast<ClientMessageType>(messageTypeTemp);

        std::string senderName;

        if (!(receivedPacket >> senderName))
            continue;

        Client tempClient{senderName, senderIp, senderPort};
        if (std::count(clients.begin(), clients.end(), tempClient) == 0)
        {
            clients.push_back(tempClient);
        }

        if (messageType == ClientMessageType::HANDSHAKE)
        {
            continue;
        }
        else if (messageType == ClientMessageType::CLIENTS_LIST_REQUEST)
        {
            sf::Packet preparedPacket;
            preparedPacket << appId_ << static_cast<std::underlying_type_t<ServerMessageType>>(ServerMessageType::CLIENT_LIST) << clients.size() - 1;
            for (auto &client : clients)
            {
                if (client != tempClient)
                    preparedPacket << client.name;
            }
            socket.send(preparedPacket, senderIp, senderPort);
        }
        else if (messageType == ClientMessageType::MESSAGE_TO_CLIENT)
        {
            std::string targetName;
            if (!(receivedPacket >> targetName))
                continue;

            const auto messageTarget = std::find_if(clients.begin(), clients.end(), [targetName](Client &c)
                                                    { return c.name == targetName; });
            if (messageTarget == clients.end())
                continue;

            std::string message;

            if (!(receivedPacket >> message))
                continue;

            sf::Packet preparedPacket;
            preparedPacket << appId_ << static_cast<std::underlying_type_t<ServerMessageType>>(ServerMessageType::MESSAGE_FROM_SOMEONE) << tempClient.name << message;

            socket.send(preparedPacket, (*messageTarget).adress, (*messageTarget).port);
        }

    } while (true);
}

void runUdpClient(unsigned short clientPort, sf::IpAddress serverIp, unsigned short serverPort)
{
    std::cout << "Client run" << std::endl;

    sf::UdpSocket socket;

    if (socket.bind(clientPort) != sf::Socket::Done)
        return;

    std::string userName;
    std::cout << "Podaj nazwe uzytkownika: ";
    std::getline(std::cin, userName);
    {
        sf::Packet preparePacket;
        preparePacket << appId_ << static_cast<std::underlying_type_t<ClientMessageType>>(ClientMessageType::HANDSHAKE) << userName;
        if (socket.send(preparePacket, serverIp, serverPort) != sf::Socket::Done)
            return;
    }

    std::vector<std::string> clientNames;

    do
    {
        int choice = 0;
        while (true)
        {
            clearConsole;
            std::cout << "1. Odswiez i pokaz liste uzytkownikow\n2. Wyslij wiadomosc\n3. Sprawdz wiadomosci" << std::endl;
            std::string temp;
            std::getline(std::cin, temp);

            try
            {
                choice = std::stoi(temp);
            }
            catch (...)
            {
                continue;
            }

            break;
        }

        if (choice == 1)
        {
            sf::Packet preparePacket;
            preparePacket << appId_ << static_cast<std::underlying_type_t<ClientMessageType>>(ClientMessageType::CLIENTS_LIST_REQUEST) << userName;
            socket.send(preparePacket, serverIp, serverPort);
            sf::Packet clientListPacket;
            sf::SocketSelector selector;
            selector.add(socket);
            if (selector.wait(sf::seconds(10.f)))
            {
                socket.receive(clientListPacket, serverIp, serverPort);
            }
            else
            {
                std::cout << "Nie udalo sie pobrac listy uzytkownikow z serwera" << std::endl;
                continue;
            }

            int32_t appId;

            if (!(clientListPacket >> appId && appId == appId_))
                continue;

            std::underlying_type_t<ServerMessageType> messageTypeTemp;
            if (!(clientListPacket >> messageTypeTemp))
                continue;

            ServerMessageType messageType = static_cast<ServerMessageType>(messageTypeTemp);

            if (messageType != ServerMessageType::CLIENT_LIST)
                continue;

            size_t clientNumber = 0;

            if (!(clientListPacket >> clientNumber))
                continue;

            bool success = true;
            std::vector<std::string> tempClientNames;

            for (int i = 0; i < clientNumber; i++)
            {
                std::string name;
                if (!(clientListPacket >> name))
                {
                    success = false;
                    break;
                }
                tempClientNames.push_back(name);
            }
            if (success)
                clientNames = tempClientNames;

            clearConsole;
            std::cout << "Dostepne osoby:" << std::endl;
            for (auto &clientName : clientNames)
            {
                std::cout << clientName << std::endl;
            }
            std::cin.ignore(10000, '\n');
        }
        else if (choice == 2)
        {
            clearConsole;
            std::cout << "Wpisz numer osoby, do ktorej chcesz wyslac wiadomosc:" << std::endl;
            int i = 1;
            for (auto &clientName : clientNames)
            {
                std::cout << i++ << ". " << clientName << std::endl;
            }

            std::string chosenClientNumber;
            std::string targetName;
            int num;

            std::getline(std::cin, chosenClientNumber);
            try
            {
                num = std::stoi(chosenClientNumber);
                num--;
            }
            catch (...)
            {
                continue;
            }

            if (num >= 0 && num < clientNames.size())
                targetName = clientNames.at(num);
            else
                continue;

            clearConsole;
            std::cout << "Napisz wiadomosc:" << std::endl;

            std::string message;
            std::getline(std::cin, message);

            sf::Packet preparePacket;
            preparePacket << appId_ << static_cast<std::underlying_type_t<ClientMessageType>>(ClientMessageType::MESSAGE_TO_CLIENT) << userName << targetName << message;

            if (socket.send(preparePacket, serverIp, serverPort) != sf::Socket::Done)
                return;

            std::cout << "Wyslano wiadomosc pomyslnie" << std::endl;
            std::cin.ignore(10000, '\n');
        }
        else if (choice == 3)
        {
            std::string messages;
            while (true)
            {
                sf::Packet receivePacket;
                sf::SocketSelector selector;
                selector.add(socket);
                if (selector.wait(sf::seconds(4.f)))
                {
                    socket.receive(receivePacket, serverIp, serverPort);
                }
                else
                {
                    std::cout << "Nie udalo sie pobrac listy uzytkownikow z serwera" << std::endl;
                    break;
                }

                int32_t appId;

                if (!(receivePacket >> appId && appId == appId_))
                    continue;

                std::underlying_type_t<ServerMessageType> messageTypeTemp;
                if (!(receivePacket >> messageTypeTemp))
                    continue;

                ServerMessageType messageType = static_cast<ServerMessageType>(messageTypeTemp);

                if (messageType != ServerMessageType::MESSAGE_FROM_SOMEONE)
                    continue;

                std::string senderName;

                if (!(receivePacket >> senderName))
                    continue;

                std::string receivedMessage;

                if (!(receivePacket >> receivedMessage))
                    continue;

                messages.append(senderName);
                messages.append(": ");
                messages.append(receivedMessage);
                messages.append("\n");
            }

            if (messages.length() > 0)
            {
                clearConsole;
                std::cout << messages;
                std::cin.ignore(10000, '\n');
            }
        }
        else if (choice == 4)
        {
            std::cout << "Server run with local ip: " << sf::IpAddress::getLocalAddress() << "\nand public ip: " << sf::IpAddress::getPublicAddress() << "\nclient port: " << socket.getLocalPort() << std::endl;
            std::cin.ignore(10000, '\n');
        }

    } while (true);
}

int main(int argc, char *argv[])
{
    const int serverPort = 50001;

    if (argc == 3)
    {
        bool success = true;
        sf::IpAddress address(argv[1]);
        if (address == sf::IpAddress::None)
            success = false;

        unsigned short port = 0;
        try
        {
            port = std::stoi(std::string(argv[2]));
        }
        catch (...)
        {
            success = false;
        }

        if (success)
            runUdpClient(port, address, serverPort);
    }

    std::cout << "c - client ; s - server ; empty - server" << std::endl;
    char choice;
    std::cin >> choice;
    std::cin.ignore(10000, '\n');

    if (choice == 'c')
        runUdpClient(sf::Socket::AnyPort, sf::IpAddress::getLocalAddress(), serverPort);
    else if (choice == 's')
        runUdpServer(serverPort);

    runUdpServer(serverPort);

    std::cin.ignore(10000, '\n');

    return 0;
}